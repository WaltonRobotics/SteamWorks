package org.usfirst.frc2974.Testbed.commands;

import org.usfirst.frc2974.Testbed.Robot;
import org.usfirst.frc2974.Testbed.RobotMap;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class Drive extends Command {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
	public Drive() {

		SmartDashboard.putString("DriveMode", "Robert");
		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
		requires(Robot.drivetrain);

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	}

	// Called just before this Command runs the first time
	protected void initialize() {
	}

	public double getLeftThrottle() {
		if (Math.abs(Robot.oi.left.getY()) < 0.3) {
			return 0;
		}
		return Robot.oi.left.getY();
	}

	public double getRightThrottle() {
		if (Math.abs(Robot.oi.right.getY()) < 0.3) {
			return 0;
		}
		return Robot.oi.right.getY();

	}
	
	public double getZThrottle() {
		if (Math.abs(Robot.oi.left.getZ()) < 0.3) {
			return 0;
		}
		return Robot.oi.right.getZ();

	}
	
	public double getTurn() {
		if (Math.abs(Robot.oi.right.getX()) < 0.3) {
			return 0;
		}
		return Robot.oi.right.getX();

	}

	public double getLeftTurn() {
		if (Math.abs(Robot.oi.left.getX()) < 0.3) {
			return 0;
		}
		return Robot.oi.left.getX();

	}

	// Called repeatedly when this Command is scheduled to run
	//change
	protected void execute() {
		if (SmartDashboard.getString("DriveMode", "Cheesy").startsWith("Tank")) {
			Robot.drivetrain.setSpeeds(-getLeftThrottle(), -getRightThrottle());
			if(SmartDashboard.getBoolean("IsCompBot",true)){
				if (Robot.oi.shiftDown.get())
					Robot.drivetrain.shiftUp();
				if (Robot.oi.shiftUp.get())
					Robot.drivetrain.shiftDown();
			}else{
				if (Robot.oi.shiftDown.get())
					Robot.drivetrain.shiftDown();
				if (Robot.oi.shiftUp.get())
					Robot.drivetrain.shiftUp();
			}
		} else if (SmartDashboard.getString("DriveMode", "Cheesy").startsWith("Chessy"))  {
			double throttle = (getLeftThrottle() + 1)/2;
			double forward = -getRightThrottle();
			double turn = getTurn();
			if(SmartDashboard.getBoolean("IsCompBot",true)){
				if (Robot.oi.shiftDown.get())
					Robot.drivetrain.shiftUp();
				if (Robot.oi.shiftUp.get())
					Robot.drivetrain.shiftDown();
			}else{
				if (Robot.oi.shiftDown.get())
					Robot.drivetrain.shiftDown();
				if (Robot.oi.shiftUp.get())
					Robot.drivetrain.shiftUp();
			}
			Robot.drivetrain.setSpeeds(throttle * (forward + turn), throttle * (forward - turn));
			//System.out.println("Cheesy Error Stuff: throttle: "+throttle+"; forward: "+forward+"; turn: "+turn+"; speeds: ("+RobotMap.left.get()+", "+(-RobotMap.right.get())+")");
		}else{
			double throttle = (Robot.oi.left.getAxis(Joystick.AxisType.kZ) + 1)/2;
			double forward = -getLeftThrottle();
			double turn = getLeftTurn();
			if(SmartDashboard.getBoolean("IsCompBot",true)){
				if (Robot.oi.shiftUp.get()||Robot.oi.shiftUpAlt.get())
					Robot.drivetrain.shiftUp();
				if (Robot.oi.shiftDown.get()||Robot.oi.shiftDownAlt.get())
					Robot.drivetrain.shiftDown();
			}else{
				if (Robot.oi.shiftDown.get()||Robot.oi.shiftDownAlt.get())
					Robot.drivetrain.shiftDown();
				if (Robot.oi.shiftUp.get()||Robot.oi.shiftUpAlt.get())
					Robot.drivetrain.shiftUp();
			}
			Robot.drivetrain.setSpeeds(throttle * (forward + turn), throttle * (forward - turn));
		}
	}

	// Make this return true when this Command no longer needs to run execute()
	protected boolean isFinished() {
		return false;
	}

	// Called once after isFinished returns true
	protected void end() {
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	protected void interrupted() {
	}
}
